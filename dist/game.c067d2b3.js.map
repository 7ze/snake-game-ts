{"version":3,"sources":["ts/input.ts","ts/snake.ts","ts/grid.ts","ts/food.ts","ts/game.ts"],"names":[],"mappings":"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","file":"game.c067d2b3.js","sourceRoot":"../src","sourcesContent":["let inputDirection = { x: 0, y: 0 };\nlet lastInputDirection = { ...inputDirection };\n\nconst handler = (e: KeyboardEvent) => {\n  switch (e.key) {\n    case 'ArrowUp':\n    case 'W':\n    case 'w':\n      if (lastInputDirection.y !== 0) break;\n      inputDirection = { x: 0, y: -1 };\n      break;\n    case 'ArrowDown':\n    case 'S':\n    case 's':\n      if (lastInputDirection.y !== 0) break;\n      inputDirection = { x: 0, y: 1 };\n      break;\n    case 'ArrowLeft':\n    case 'A':\n    case 'a':\n      if (lastInputDirection.x !== 0) break;\n      inputDirection = { x: -1, y: 0 };\n      break;\n    case 'ArrowRight':\n    case 'D':\n    case 'd':\n      if (lastInputDirection.x !== 0) break;\n      inputDirection = { x: 1, y: 0 };\n      break;\n  }\n};\n\nwindow.addEventListener('keydown', handler);\n\nexport const getInputDirection = () => {\n  lastInputDirection = inputDirection;\n  return inputDirection;\n};\n","import { getInputDirection } from './input';\n\nexport const SNAKE_SPEED = 5; // * Speed in fps *\n\nconst snakeBody = [{ x: 11, y: 11 }];\nlet newSegments = 0;\n\nexport const update = (): void => {\n  // logic to move the snake\n  addSegments();\n  const inputDirection = getInputDirection();\n\n  for (let i = snakeBody.length - 2; i >= 0; i--) {\n    snakeBody[i + 1] = { ...snakeBody[i] };\n  }\n\n  snakeBody[0].x += inputDirection.x;\n  snakeBody[0].y += inputDirection.y;\n};\n\nexport const draw = (gameBoard: HTMLDivElement): void => {\n  snakeBody.forEach((segment) => {\n    const snakeElement = document.createElement('div');\n    snakeElement.style.gridRowStart = `${segment.y}`;\n    snakeElement.style.gridColumnStart = `${segment.x}`;\n    snakeElement.classList.add('snake');\n    gameBoard.appendChild(snakeElement);\n  });\n};\n\nexport const snakeIsOnPosition = (\n  position: { x: number; y: number },\n  { ignoreHead = false } = {}\n) => {\n  return snakeBody.some((segment, index) => {\n    if (ignoreHead && !index) return false;\n    return equalsPosition(segment, position);\n  });\n};\n\nexport const isIntersected = () => {\n  return snakeIsOnPosition(getSnakeHead(), { ignoreHead: true });\n};\n\nexport const expandSnake = (growth: number) => {\n  newSegments += growth;\n};\n\nexport const getSnakeHead = () => {\n  return snakeBody[0];\n};\n\nconst equalsPosition = (\n  positionOne: { x: number; y: number },\n  positionTwo: { x: number; y: number }\n) => {\n  return positionOne.x === positionTwo.x && positionOne.y === positionTwo.y;\n};\n\nconst addSegments = () => {\n  for (let i = 0; i < newSegments; i++) {\n    snakeBody.push({ ...snakeBody[snakeBody.length - 1] });\n  }\n  newSegments = 0;\n};\n","const GRID_SIZE = 21;\n\nconst getRandom = (limit: number) => {\n  return (Math.floor(Math.random() * 1000) % limit) + 1;\n};\n\nexport const randomGridPosition = () => {\n  return { x: getRandom(GRID_SIZE), y: getRandom(GRID_SIZE) };\n};\n\nexport function isOutsideGrid(position: { x: number; y: number }): boolean {\n  return (\n    position.x < 1 ||\n    position.x > GRID_SIZE ||\n    position.y < 1 ||\n    position.y > GRID_SIZE\n  );\n}\n","import { randomGridPosition } from './grid';\nimport { expandSnake, snakeIsOnPosition as snakeIsOnFood } from './snake';\n\nconst getRandomFoodPosition = () => {\n  let newFoodPosition: { x: number; y: number };\n  while (!newFoodPosition || snakeIsOnFood(newFoodPosition)) {\n    newFoodPosition = randomGridPosition();\n  }\n  return newFoodPosition;\n};\n\nlet food = getRandomFoodPosition();\nconst EXPANSION_RATE = 1;\n\nexport const update = () => {\n  if (snakeIsOnFood(food)) {\n    expandSnake(EXPANSION_RATE);\n    food = getRandomFoodPosition();\n  }\n};\n\nexport const draw = (gameBoard: HTMLDivElement): void => {\n  const foodElement = document.createElement('div');\n  foodElement.style.gridRowStart = `${food.y}`;\n  foodElement.style.gridColumnStart = `${food.x}`;\n  foodElement.classList.add('food');\n  gameBoard.appendChild(foodElement);\n};\n","import {\n  SNAKE_SPEED,\n  update as updateSnake,\n  draw as drawSnake,\n  getSnakeHead,\n  isIntersected,\n} from './snake';\nimport { update as updateFood, draw as drawFood } from './food';\nimport { isOutsideGrid } from './grid';\nimport { strict } from 'assert';\n\nlet lastRenderTime = 0;\nlet gameOver = false;\nconst gameBoard: HTMLDivElement = document.querySelector('#game-board');\n\nconst main = (currentTime: number) => {\n  if (gameOver) {\n    if (confirm('You lost. Press Ok to restart.')) {\n      window.location.href = '/';\n    }\n    return;\n  }\n\n  window.requestAnimationFrame(main);\n  const secondsSinceLastRender = (currentTime - lastRenderTime) / 1000;\n  if (secondsSinceLastRender < 1 / SNAKE_SPEED) return;\n\n  lastRenderTime = currentTime;\n\n  update();\n  draw();\n};\n\nwindow.requestAnimationFrame(main);\n\nconst update = () => {\n  updateSnake();\n  updateFood();\n  checkDeath();\n};\n\nconst draw = () => {\n  gameBoard.innerHTML = '';\n  drawSnake(gameBoard);\n  drawFood(gameBoard);\n};\n\nconst checkDeath = () => {\n  gameOver = isOutsideGrid(getSnakeHead()) || isIntersected();\n};\n"]}